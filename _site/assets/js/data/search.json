[
  
  {
    "title": "[React-query] React-query 사용예제",
    "url": "/posts/React-Query-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%A0%9C/",
    "categories": "Development, Library",
    "tags": "React-query, React",
    "date": "2024-02-22 20:00:00 +0900",
    





    
    "snippet": "React-query 사용 예제기존 코드const Coins = () =&gt; {const [coins, setCoins] = useState&lt;ICoin[]&gt;([]); // 통신으로 받아온 coins data 상태관리const [loading, setLoading] = useState(true); // 통신 과정 상태관리useEffect(...",
    "content": "React-query 사용 예제기존 코드const Coins = () =&gt; {const [coins, setCoins] = useState&lt;ICoin[]&gt;([]); // 통신으로 받아온 coins data 상태관리const [loading, setLoading] = useState(true); // 통신 과정 상태관리useEffect(() =&gt; { // 화면 mount 시 해당 함수 실행(async () =&gt; {const res = await fetch(\"httpspi.coinpaprika.com/v1/coins\"); // data 요청const data = await res.json();setCoins(data.slice(0, 100)); // api 요청으로 받아온 data 상태 업데이트setLoading(false); // 상태 업데이트 후 통신 과정 업데이트})();}, []);&lt;Container&gt;&lt;Header&gt;  &lt;Title&gt;코인&lt;/Title&gt;&lt;/Header&gt;// loading의 boolean 값을 보고 화면 rander 결정  {loading ? (  &lt;Loader&gt;loading...&lt;/Loader&gt;  ) : (    &lt;CoinList&gt;    // 받아온 data를 뿌려주는 과정      {data?.slice(0, 100).map((coin) =&gt; (        &lt;Coin key={coin.id}&gt;          &lt;Link to={`/${coin.id}`} state={{ name: coin.name }}&gt;              &lt;Img              src={`https://cryptocurrencyliveprices.com/img/${coin.id}.png`} alt=\"\"              /&gt;              {coin.name} &amp;rarr;            &lt;/Link&gt;          &lt;/Coin&gt;        ))      }    &lt;/CoinList&gt;  )}&lt;/Container&gt;  );};React Query 코드// src/api.tsconst BASE_URL = \"https://api.coinpaprika.com/v1\";export const fetchCoins = () =&gt; {  return fetch(`${BASE_URL}/coins`).then((res) =&gt; res.json());};// src/routes/Conins.tsxconst Coins = () =&gt; {const { isLoading, data } = useQuery&lt;ICoin[]&gt;('allCoins', fetchCoins);// isLoading: boolean값으로 반환// data: api 통신으로 받아온 data를 반환// allCoins: 고유한 값 지정// fetchCoins: api라는 파일을 따로 만든 후 그곳에서 해당 api 통신을 진행 한 함수를 등록&lt;Container&gt;  &lt;Header&gt;    &lt;Title&gt;코인&lt;/Title&gt;  &lt;/Header&gt;  {isLoading ? ( // isLoading의 boolean 값을 보고 화면 rander 결정    &lt;Loader&gt;loading...&lt;/Loader&gt;    ) : (    &lt;CoinList&gt;      // 받아온 data를 뿌려주는 과정      {data?.slice(0, 100).map((coin) =&gt; (        &lt;Coin key={coin.id}&gt;          &lt;Link to={`/${coin.id}`} state={{ name: coin.name }}&gt;            &lt;Img            src={`https://cryptocurrencyliveprices.com/img/${coin.id}.png`} alt=\"\"            /&gt;            {coin.name} &amp;rarr;          &lt;/Link&gt;        &lt;/Coin&gt;        ))      }    &lt;/CoinList&gt;    )}&lt;/Container&gt;  );};api 통신을 2번 해야하는 상황// src/api.tsconst BASE_URL = \"https://api.coinpaprika.com/v1\";export const fetchCoinInfo = (coinId: string) =&gt; {return fetch(`${BASE_URL}/coins/${coinId}`).then((res) =&gt; res.json());};export const fetchCoinTickers = (coinId: string) =&gt; {return fetch(`${BASE_URL}/tichers/${coinId}`).then((res) =&gt; res.json());};// src/routes/coin.tsxconst Coin = () =&gt; {  const { isLoading: infoLoading, data: infoData } = useQuery&lt;InfoData&gt;(      [\"info\", coinId],      () =&gt; fetchCoinInfo(coinId)    );  const { isLoading: tickersLoading, data: tickersData } = useQuery&lt;PriceData&gt;(      [\"tickers\", coinId],      () =&gt; fetchCoinTickers(coinId)    );// isLoading, data의 이름이 중복되기 때문에 각각의 고유한 이름으로 설정// [\"info\", coinId] -&gt; 고유한 값 설정 부분에서도 coinId가 중복되기 때문에 고유한 값을 같이 설정// 함수 등록 과정에서도 해당 함수에 coinId라는 인수가 필요하여 함수 자체를 설정const loading = infoLoading || tickersLoading; // infoLoading, tickersLoading이둘 다 true가 나올때만 실행사용 후기  사용성: 사용성 측면에서 굉장히 편한 사용 방법과 코드의 양을 줄여줄 수 있었다. 상태관리가 따로 필요하지 않고isLoading이라는 boolean값을 반환하기 때문에 통신에 따라 화면 설정 과정에서도 편리했다  성능: 성능 또한 받아온 data를 cashing하는 기능이 있기 때문에 재렌더링 시 통신이 일어나지 않아성능 상으로도 뛰어나다고 생각한다.  api 통신에서 React Query를 적극 활용할 생각이다."
  },
  
  {
    "title": "[Git] Git 명령어 정리",
    "url": "/posts/git%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/",
    "categories": "Development, Git",
    "tags": "git",
    "date": "2024-02-22 17:30:00 +0900",
    





    
    "snippet": "git merge 3가지 방법  3-way merge브랜치 각각(ex: main branch와 dev branch)에 신규 commit이 1회 이상 있는 경우 merge를 하게 되면 두 branch 코드가 합쳐져서 main branch에 새로운 commit이 생성되는 것.  fast-forwordmain branch에는 새로운 commit이 없고 de...",
    "content": "git merge 3가지 방법  3-way merge브랜치 각각(ex: main branch와 dev branch)에 신규 commit이 1회 이상 있는 경우 merge를 하게 되면 두 branch 코드가 합쳐져서 main branch에 새로운 commit이 생성되는 것.  fast-forwordmain branch에는 새로운 commit이 없고 dev branch(만든 branch)에만 새로운 commit이 있는 경우 dev branch를 main branch라고 선언하게 된다. 즉, 분기가 없어지고 main에서 새로운commit이 생성된 것과 같은 현상이 발생.      rebase &amp; mergerebase를 이용해서 신규 branch의 시작점을 main branch의 최근 commit으로 옮긴 다음 fast-forword merge 하는 방법.    revbase &amp; merge 하는 이유\t1. 3-way-merge 말고 강제로 fast-forword merge 하고 싶은 경우\t2. commit 내역을 한 줄로 계속 이어서 남기고 싶은 경우사용 방법\t1. 새로운 branch 이동\t2. `git rebase main` 명령어 사용\t3. main branch에서 fast-forword merge      코드 되돌리기      git restore [파일명]최근 commit된 상태로 현재 파일의 수정내역을 되돌린다.        git restore –source [commit아이디] [파일명] 입력한 파일이 특정 commit 아이디 시점으로 되돌아 간다.        git resotre –staged [파일명] 특정 파일을 staging 취소.        git revert [commit아이디]    kl2j32k c작업lkljlk4 b작업lk34j33 a작업              예를 들어 위와 같은 commit 내역이 있는 경우 b작업 내역을 지우고 싶다면git revert [commit아이디] 명령어로 b작업 취소 -&gt; c작업에는 영향 없음.      그냥 최근 commit 내역을 삭제하고 싶다면 git revert HEAD            git reset –hard [commit아이디]          git reset --hard [commit아이디] 명령어는 협업시 사용하지 않는 것이 좋다.      다른 개발자의 작업까지 취소해버리는 위험한 명령어      그래서 짧은 commit내역으로 돌아가거나 혼자 작업할 경우 유용함            git reset –soft [commit아이디]reset를 하긴하는데 hard 옵션과 같이 전부 삭제하는 것이 아닌 해당 commit이 staging 형태로 남아 있음        git reset –mixed [commit아이디]reset를 하는데 해당 commit 했던 내역이 staging 형태도 아닌 수정된 상태에서 남아 있음 -&gt; git add전 상태  원격저장소 관련  원격저장소에서 repository 생성 후 로컬과 연결          원격저장소에서 새로운 repository 생성      git init : 작업 폴더에 로컬 git repository 생성      git branch -M main : main branch이름을 main으로 지정      git push -u [원격저장소주소] main : 원격저장소에 push      git remote add origin [원격저장소주소] : 원격저장소 주소를 매번 쓰기 귀찮으니 origin이라는 변수명에 담는 과정      .gitignore      원격저장소에 올리고 싶지 않은 파일을 .gitignore에 입력하면 원격 저장소에 안올라간다.      보통 node_modules 나 .env 파일은 올리지 않음      git branch 전략 2가지      git flow          main : main branch      develop : main에서 merge를 바로 해버리면 위험하다고 판단하여 develop branch를 생성하여 확인 후 main에 merge      feature : develop branch에서 기능 단위로 개발할 경우 feature branch를 생성하여 기능 개발 후 develop branch로 merg      release : main branch에 merge하기 전 release branch에서 QA나 여러가지 테스트 진행      hotfix : 긴급하게 수정해야 되는 경우 hotfix branch를 생성하여 작업 후 merge            Trunk-Based          main branch에서 기능 개발 branch인 feature branch를 생성하거나 hotfix branch를 생성하여 완료되면 main branch에 바로 merge      이 전략은 테스트 자동화나 철저한 코드리뷰가 바탕이 되었을 경우 진행      아니면, 초반에는 git flow 전략으로 개발을 진행하다가 어느정도 안정화가 이루어 진 후trunk-based 전략으로 변경하는 것도 좋은 방법      코드 임시 보관      git stash          방금 작성한 코드가 임시 저장된다      staging 된 것이든 안 된 것이든 임시 저장됨      git stash save 'message' 메시지와 같이 임시 저장      stash 목록이 많은 경우 찾기 좋음            git stash list          git stash한 리스트 목록 확인            git stash pop          최근 stash한 코드를 불러온다      당연히 겹치는 코드가 있다면 conflict가 발생            git stash drop [삭제할 id]          git stash 목록에서 원하는 목록 삭제      삭제할 id는 git stash list 하면 보이는 아이디(ex: 0,1,2 등등)      "
  }
  
]

